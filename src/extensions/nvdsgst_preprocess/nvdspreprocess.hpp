#pragma once

#include <string>

#include "nvdsbase/nvds_io.hpp"

namespace nvidia {
namespace deepstream {

class GstNvDsPreProcess : public INvDsElement {
 public:
  gxf_result_t initialize() override {
    GXF_LOG_INFO("initialize: %s %s\n", GST_ELEMENT_NAME, name());
    return GXF_SUCCESS;
  }

  gxf_result_t create_element() override {
    std::string ename = entity().name();
    ename += "/";
    ename += name();
    GXF_LOG_INFO("create_element: %s %s\n", GST_ELEMENT_NAME, name());
    element_ = gst_element_factory_make(GST_ELEMENT_NAME, ename.c_str());

    if (!element_) {
      GXF_LOG_ERROR("Could not create GStreamer element '%s'",
                    GST_ELEMENT_NAME);
      return GXF_FAILURE;
    }

    auto p_src_pad = src_pad.try_get();
    if (p_src_pad) {
      p_src_pad.value()->set_element(this);
      p_src_pad.value()->set_template_name("src");
    }

    auto p_sink_pad = sink_pad.try_get();
    if (p_sink_pad) {
      p_sink_pad.value()->set_element(this);
      p_sink_pad.value()->set_template_name("sink");
    }
    return GXF_SUCCESS;
  }

  gxf_result_t bin_add(GstElement *pipeline) override {
    GXF_LOG_INFO("bin_add: %s %s\n", GST_ELEMENT_NAME, name());
    if (!gst_bin_add(GST_BIN(pipeline), element_)) {
      return GXF_FAILURE;
    }

    auto p_qos = qos.try_get();
    if (p_qos && p_qos.value() != false) {
      gboolean propvalue = (gboolean)p_qos.value();
      g_object_set(element_, "qos", propvalue, NULL);
    }

    auto p_unique_id = unique_id.try_get();
    if (p_unique_id && p_unique_id.value() != 15UL) {
      guint propvalue = (guint)p_unique_id.value();
      g_object_set(element_, "unique-id", propvalue, NULL);
    }

    auto p_enable = enable.try_get();
    if (p_enable && p_enable.value() != true) {
      gboolean propvalue = (gboolean)p_enable.value();
      g_object_set(element_, "enable", propvalue, NULL);
    }

    auto p_gpu_id = gpu_id.try_get();
    if (p_gpu_id && p_gpu_id.value() != 0UL) {
      guint propvalue = (guint)p_gpu_id.value();
      g_object_set(element_, "gpu-id", propvalue, NULL);
    }

    auto p_process_on_frame = process_on_frame.try_get();
    if (p_process_on_frame && p_process_on_frame.value() != true) {
      gboolean propvalue = (gboolean)p_process_on_frame.value();
      g_object_set(element_, "process-on-frame", propvalue, NULL);
    }

    auto p_operate_on_gie_id = operate_on_gie_id.try_get();
    if (p_operate_on_gie_id && p_operate_on_gie_id.value() != -1L) {
      gint propvalue = (gint)p_operate_on_gie_id.value();
      g_object_set(element_, "operate-on-gie-id", propvalue, NULL);
    }

    auto p_target_unique_ids = target_unique_ids.try_get();
    if (p_target_unique_ids && p_target_unique_ids.value() != std::string{""}) {
      gchararray propvalue = (gchararray)p_target_unique_ids.value().c_str();
      g_object_set(element_, "target-unique-ids", propvalue, NULL);
    }

    auto p_config_file = config_file.try_get();
    if (p_config_file && p_config_file.value() != std::string{""}) {
      gchararray propvalue = (gchararray)p_config_file.value().c_str();
      g_object_set(element_, "config-file", propvalue, NULL);
    }

    return GXF_SUCCESS;
  }

  GstElement *get_element_ptr() override { return element_; }

  gxf_result_t registerInterface(nvidia::gxf::Registrar *registrar) override {
    nvidia::gxf::Expected<void> result;
    result &= registrar->parameter(qos, "qos", "QoS",
                                   "Handle Quality-of-Service events", false,
                                   GXF_PARAMETER_FLAGS_OPTIONAL);
    result &= registrar->parameter(unique_id, "unique-id", "Unique ID",
                                   "Unique ID for the element. Can be used to "
                                   "identify output of the element",
                                   15UL, GXF_PARAMETER_FLAGS_OPTIONAL);
    result &= registrar->parameter(
        enable, "enable", "Enable",
        "Enable gst-nvdspreprocess plugin, or set in passthrough mode", true,
        GXF_PARAMETER_FLAGS_OPTIONAL);
    result &= registrar->parameter(gpu_id, "gpu-id", "Set GPU Device ID",
                                   "Set GPU Device ID", 0UL,
                                   GXF_PARAMETER_FLAGS_OPTIONAL);
    result &= registrar->parameter(
        process_on_frame, "process-on-frame", "Process On Frame",
        "Process On Frame or Objects", true, GXF_PARAMETER_FLAGS_OPTIONAL);
    result &= registrar->parameter(
        operate_on_gie_id, "operate-on-gie-id", "Preprocess on Gie ID",
        "Preprocess on metadata generated by GIE with this unique ID. Set to "
        "-1 to infer on all metadata.",
        -1L, GXF_PARAMETER_FLAGS_OPTIONAL);
    result &= registrar->parameter(
        target_unique_ids, "target-unique-ids", "Target Unique Ids",
        "list of component gie-id for which tensor is prepared Use string with "
        "values of gie-id of infer components (int) to set the property. e.g. "
        "3;4;5",
        std::string{""}, GXF_PARAMETER_FLAGS_OPTIONAL);
    result &=
        registrar->parameter(config_file, "config-file",
                             "Preprocess Config File", "Preprocess Config File",
                             std::string{""}, GXF_PARAMETER_FLAGS_OPTIONAL);
    result &= registrar->parameter(
        src_pad, "video-out", "video-out",
        "Handle to a nvidia::deepstream::NvDsStaticOutput component. Supported "
        "formats - video(NV12, RGBA, I420)",
        gxf::Registrar::NoDefaultParameter(), GXF_PARAMETER_FLAGS_OPTIONAL);
    result &= registrar->parameter(
        sink_pad, "video-in", "video-in",
        "Handle to a nvidia::deepstream::NvDsStaticInput component. Supported "
        "formats - video(NV12, RGBA, I420)",
        gxf::Registrar::NoDefaultParameter(), GXF_PARAMETER_FLAGS_OPTIONAL);
    return nvidia::gxf::ToResultCode(result);
  }

  nvidia::gxf::Parameter<bool> qos;
  nvidia::gxf::Parameter<uint64_t> unique_id;
  nvidia::gxf::Parameter<bool> enable;
  nvidia::gxf::Parameter<uint64_t> gpu_id;
  nvidia::gxf::Parameter<bool> process_on_frame;
  nvidia::gxf::Parameter<int64_t> operate_on_gie_id;
  nvidia::gxf::Parameter<std::string> target_unique_ids;
  nvidia::gxf::Parameter<std::string> config_file;
  nvidia::gxf::Parameter<nvidia::gxf::Handle<NvDsStaticOutput>> src_pad;
  nvidia::gxf::Parameter<nvidia::gxf::Handle<NvDsStaticInput>> sink_pad;

 protected:
  GstElement *element_;
  const char *GST_ELEMENT_NAME = "nvdspreprocess";
};

#define GXF_EXT_FACTORY_ADD_GstNvDsPreProcess()                         \
  do {                                                                  \
    GXF_EXT_FACTORY_ADD_VERBOSE(                                        \
        0x5c590f617d6c3c99UL, 0x939153ab18648ae4UL,                     \
        nvidia::deepstream::GstNvDsPreProcess,                          \
        nvidia::deepstream::INvDsElement,                               \
        "GstNvDsPreProcess placeholder display-name",                   \
        "GstNvDsPreProcess placeholder brief",                          \
        "Preprocessing using custom algorithms for different streams"); \
  } while (0)

}  // namespace deepstream
}  // namespace nvidia
